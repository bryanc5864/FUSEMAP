#!/usr/bin/env python3
"""
APBS Calibration Pipeline for Electrostatic Potential Descriptor

This script:
1. Reads calibration panel sequences
2. Generates 3D B-DNA structures using fiber/3DNA
3. Runs PDB2PQR for charge assignment
4. Runs APBS for electrostatic potential calculation
5. Extracts scalar ψ_APBS values from potential maps
6. Fits regression model: ψ_APBS = f(GC_frac, CpG_density, run_frac)
7. Saves calibration model for use in physics annotation pipeline

Requirements:
- APBS, PDB2PQR, AmberTools in conda environment
- gridDataFormats for reading DX files
"""

import os
import sys
import subprocess
import pandas as pd
import numpy as np
from pathlib import Path
import json
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from sklearn.metrics import r2_score
import matplotlib.pyplot as plt
import seaborn as sns

class APBSCalibration:
    def __init__(self, work_dir="calibration_panel"):
        self.work_dir = Path(work_dir)
        self.work_dir.mkdir(exist_ok=True)
        
        # File templates
        self.apbs_template = """read
  mol pqr {pqr_file}
end

elec
  mg-auto
  lpbe
  pdie 2.0
  sdie 78.5
  ion charge 1 conc 0.15 radius 2.0
  ion charge -1 conc 0.15 radius 2.0
  srfm smol
  chgm spl4
  sdens 10.0
  temp 298.15
  calcenergy total
  calcforce no
  write pot dx {out_prefix}
end
"""
    
    def load_sequences(self, tsv_file="calibration_sequences.tsv"):
        """Load calibration panel sequences."""
        df = pd.read_csv(tsv_file, sep='\t')
        print(f"Loaded {len(df)} calibration sequences")
        return df
    
    def generate_structure(self, sequence_id, sequence):
        """Generate 3D B-DNA structure using fiber or NAB."""
        pdb_file = self.work_dir / f"{sequence_id}.pdb"
        
        # Method 1: Try using fiber from 3DNA if available
        try:
            # Create temporary sequence file
            seq_file = self.work_dir / f"{sequence_id}.seq"
            with open(seq_file, 'w') as f:
                f.write(sequence)
            
            # Use fiber to generate B-DNA
            cmd = f"cd {self.work_dir} && fiber -seq={sequence} -b"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0 and os.path.exists(self.work_dir / "Bdna.pdb"):
                subprocess.run(f"mv {self.work_dir}/Bdna.pdb {pdb_file}", shell=True)
                print(f"Generated structure for {sequence_id} using fiber")
                return True
        except Exception as e:
            print(f"fiber failed for {sequence_id}: {e}")
        
        # Method 2: Use NAB from AmberTools as fallback
        try:
            nab_script = f"""
molecule m;
m = bdna("{sequence}");
putpdb("{pdb_file}", m);
"""
            nab_file = self.work_dir / f"{sequence_id}.nab"
            with open(nab_file, 'w') as f:
                f.write(nab_script)
            
            cmd = f"cd {self.work_dir} && nab {nab_file} && ./{sequence_id}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0 and pdb_file.exists():
                print(f"Generated structure for {sequence_id} using NAB")
                return True
        except Exception as e:
            print(f"NAB failed for {sequence_id}: {e}")
        
        # Method 3: Simple B-DNA geometry as last resort
        if not pdb_file.exists():
            print(f"Using simple B-DNA template for {sequence_id}")
            self.create_simple_bdna(sequence_id, sequence)
            return pdb_file.exists()
        
        return False
    
    def create_simple_bdna(self, sequence_id, sequence):
        """Create simple B-DNA structure with standard geometry."""
        pdb_file = self.work_dir / f"{sequence_id}.pdb"
        
        # Simple B-DNA parameters
        rise_per_bp = 3.38  # Angstroms
        twist_per_bp = 36.0  # degrees
        base_radius = 10.0  # Angstroms (approximate)
        
        lines = []
        lines.append("HEADER    DNA B-FORM STRUCTURE")
        lines.append("REMARK    Generated by simple B-DNA template")
        
        atom_num = 1
        
        for i, base in enumerate(sequence):
            z = i * rise_per_bp
            angle = np.radians(i * twist_per_bp)
            
            # Simplified atom positions (just backbone and base centers)
            # This is very crude but sufficient for APBS electrostatic calculation
            
            # Phosphate
            x_p = base_radius * np.cos(angle)
            y_p = base_radius * np.sin(angle)
            lines.append(f"ATOM  {atom_num:5d}  P   DNA A{i+1:4d}    {x_p:8.3f}{y_p:8.3f}{z:8.3f}  1.00 20.00           P")
            atom_num += 1
            
            # Sugar C1'
            x_c = (base_radius - 2.0) * np.cos(angle)
            y_c = (base_radius - 2.0) * np.sin(angle)
            lines.append(f"ATOM  {atom_num:5d}  C1' DNA A{i+1:4d}    {x_c:8.3f}{y_c:8.3f}{z:8.3f}  1.00 20.00           C")
            atom_num += 1
            
            # Base center (simplified)
            x_b = (base_radius - 5.0) * np.cos(angle)
            y_b = (base_radius - 5.0) * np.sin(angle)
            base_atom = 'N1' if base in 'CT' else 'N9'  # Pyrimidine vs purine
            lines.append(f"ATOM  {atom_num:5d} {base_atom:4s} D{base} A{i+1:4d}    {x_b:8.3f}{y_b:8.3f}{z:8.3f}  1.00 20.00           N")
            atom_num += 1
        
        lines.append("END")
        
        with open(pdb_file, 'w') as f:
            f.write('\n'.join(lines))
        
        print(f"Created simple B-DNA structure for {sequence_id}")
    
    def run_pdb2pqr(self, sequence_id):
        """Convert PDB to PQR using PDB2PQR."""
        pdb_file = self.work_dir / f"{sequence_id}.pdb"
        pqr_file = self.work_dir / f"{sequence_id}.pqr"
        
        cmd = f"pdb2pqr30 --ff=amber --with-ph=7.0 {pdb_file} {pqr_file}"
        
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, 
                                  cwd=self.work_dir)
            
            if result.returncode == 0 and pqr_file.exists():
                print(f"PDB2PQR successful for {sequence_id}")
                return True
            else:
                print(f"PDB2PQR failed for {sequence_id}:")
                print(f"stdout: {result.stdout}")
                print(f"stderr: {result.stderr}")
                return False
        except Exception as e:
            print(f"PDB2PQR error for {sequence_id}: {e}")
            return False
    
    def run_apbs(self, sequence_id):
        """Run APBS calculation."""
        pqr_file = self.work_dir / f"{sequence_id}.pqr"
        apbs_input = self.work_dir / f"{sequence_id}.in"
        dx_file = self.work_dir / f"{sequence_id}_pot.dx"
        log_file = self.work_dir / f"{sequence_id}.log"
        
        # Create APBS input file
        input_content = self.apbs_template.format(
            pqr_file=f"{sequence_id}.pqr",
            out_prefix=f"{sequence_id}_pot"
        )
        
        with open(apbs_input, 'w') as f:
            f.write(input_content)
        
        # Run APBS
        cmd = f"apbs {sequence_id}.in > {sequence_id}.log 2>&1"
        
        try:
            result = subprocess.run(cmd, shell=True, cwd=self.work_dir, 
                                  capture_output=True, text=True)
            
            if dx_file.exists():
                print(f"APBS successful for {sequence_id}")
                return True
            else:
                print(f"APBS failed for {sequence_id}")
                print(f"Check log file: {log_file}")
                return False
        except Exception as e:
            print(f"APBS error for {sequence_id}: {e}")
            return False
    
    def extract_potential(self, sequence_id, shell_inner=2.0, shell_outer=6.0):
        """Extract scalar potential from DX file."""
        dx_file = self.work_dir / f"{sequence_id}_pot.dx"
        pqr_file = self.work_dir / f"{sequence_id}.pqr"
        
        try:
            # Try importing gridDataFormats
            try:
                import gridData
                grid_data = gridData.Grid(str(dx_file))
                grid = grid_data.grid
                origin = np.array(grid_data.origin)
                delta = np.array(grid_data.delta)
            except ImportError:
                # Fallback: manual DX parsing
                grid, origin, delta = self.parse_dx_manual(dx_file)
            
            # Load atom coordinates from PQR
            atoms = self.load_pqr_coords(pqr_file)
            
            # Create grid coordinate arrays
            nx, ny, nz = grid.shape
            idx = np.mgrid[0:nx, 0:ny, 0:nz].reshape(3, -1).T
            xyz = origin + idx * delta
            
            # Calculate distance to nearest atom for each grid point
            distances = np.sqrt(((xyz[:, None, :] - atoms[None, :, :]) ** 2).sum(axis=2))
            min_distances = distances.min(axis=1)
            
            # Select points in solvent shell
            mask = (min_distances >= shell_inner) & (min_distances <= shell_outer)
            shell_potentials = grid.ravel()[mask]
            
            # Remove NaN/inf values
            shell_potentials = shell_potentials[np.isfinite(shell_potentials)]
            
            if len(shell_potentials) > 0:
                psi_mean = np.mean(shell_potentials)
                psi_std = np.std(shell_potentials)
                print(f"Extracted potential for {sequence_id}: ψ = {psi_mean:.3f} ± {psi_std:.3f}")
                return psi_mean, psi_std
            else:
                print(f"No valid shell points found for {sequence_id}")
                return np.nan, np.nan
                
        except Exception as e:
            print(f"Error extracting potential for {sequence_id}: {e}")
            return np.nan, np.nan
    
    def parse_dx_manual(self, dx_file):
        """Manual DX file parser."""
        with open(dx_file, 'r') as f:
            lines = f.readlines()
        
        # Parse header
        for i, line in enumerate(lines):
            if line.startswith('object 1 class gridpositions counts'):
                nx, ny, nz = map(int, line.split()[-3:])
                break
        
        for i, line in enumerate(lines):
            if line.startswith('origin'):
                origin = np.array([float(x) for x in line.split()[1:4]])
                break
        
        for i, line in enumerate(lines):
            if line.startswith('delta') and 'delta 0' not in line:
                delta = np.array([float(x) for x in line.split()[1:4]])
                break
        
        # Find data start
        data_start = None
        for i, line in enumerate(lines):
            if line.startswith('object 3 class array'):
                data_start = i + 1
                break
        
        # Read data
        data = []
        for line in lines[data_start:]:
            if line.strip() and not line.startswith('attribute'):
                data.extend([float(x) for x in line.split()])
        
        grid = np.array(data).reshape((nx, ny, nz))
        return grid, origin, delta
    
    def load_pqr_coords(self, pqr_file):
        """Load atom coordinates from PQR file."""
        coords = []
        with open(pqr_file, 'r') as f:
            for line in f:
                if line.startswith(('ATOM', 'HETATM')):
                    x = float(line[30:38])
                    y = float(line[38:46])  
                    z = float(line[46:54])
                    coords.append([x, y, z])
        return np.array(coords)
    
    def fit_regression_model(self, df):
        """Fit regression model to calibration data."""
        # Prepare features
        X = df[['gc_frac', 'cpg_density', 'run_frac']].values
        y = df['psi_APBS'].values
        
        # Remove NaN values
        valid_mask = np.isfinite(y)
        X = X[valid_mask]
        y = y[valid_mask]
        
        if len(y) < 3:
            raise ValueError("Insufficient valid data points for regression")
        
        # Try different models
        models = {}
        
        # Linear model
        lr = LinearRegression()
        lr.fit(X, y)
        models['linear'] = {
            'model': lr,
            'r2': r2_score(y, lr.predict(X)),
            'features': ['gc_frac', 'cpg_density', 'run_frac']
        }
        
        # Polynomial degree 2
        poly2 = PolynomialFeatures(degree=2, include_bias=True)
        X_poly2 = poly2.fit_transform(X)
        lr_poly2 = LinearRegression()
        lr_poly2.fit(X_poly2, y)
        models['poly2'] = {
            'model': lr_poly2,
            'preprocessor': poly2,
            'r2': r2_score(y, lr_poly2.predict(X_poly2)),
            'features': poly2.get_feature_names_out(['gc_frac', 'cpg_density', 'run_frac'])
        }
        
        # Select best model
        best_name = max(models.keys(), key=lambda k: models[k]['r2'])
        best_model = models[best_name]
        
        print(f"Best model: {best_name} (R² = {best_model['r2']:.3f})")
        
        return best_model, models
    
    def run_full_calibration(self, tsv_file="calibration_sequences.tsv"):
        """Run complete calibration pipeline."""
        print("=== APBS Calibration Pipeline ===")
        
        # Load sequences
        df = self.load_sequences(tsv_file)
        
        # Process each sequence
        results = []
        
        for _, row in df.iterrows():
            seq_id = row['id']
            sequence = row['seq']
            
            print(f"\nProcessing {seq_id}: {sequence}")
            
            # Generate structure
            if not self.generate_structure(seq_id, sequence):
                print(f"Failed to generate structure for {seq_id}")
                continue
            
            # Run PDB2PQR
            if not self.run_pdb2pqr(seq_id):
                print(f"Failed PDB2PQR for {seq_id}")
                continue
            
            # Run APBS
            if not self.run_apbs(seq_id):
                print(f"Failed APBS for {seq_id}")
                continue
            
            # Extract potential
            psi_mean, psi_std = self.extract_potential(seq_id)
            
            # Store results
            result = row.to_dict()
            result['psi_APBS'] = psi_mean
            result['psi_std'] = psi_std
            results.append(result)
        
        # Create results dataframe
        results_df = pd.DataFrame(results)
        results_file = self.work_dir / "calibration_results.tsv"
        results_df.to_csv(results_file, sep='\t', index=False)
        
        print(f"\nCalibration results saved to {results_file}")
        print(f"Successfully processed {len(results_df)} sequences")
        
        # Fit regression model
        if len(results_df) >= 3:
            try:
                best_model, all_models = self.fit_regression_model(results_df)
                
                # Save model
                model_file = self.work_dir / "electrostatic_model.json"
                self.save_model(best_model, model_file)
                
                print(f"Regression model saved to {model_file}")
                
                # Create visualization
                self.plot_calibration_results(results_df, best_model)
                
                return results_df, best_model
                
            except Exception as e:
                print(f"Model fitting failed: {e}")
                return results_df, None
        else:
            print("Insufficient data for model fitting")
            return results_df, None
    
    def save_model(self, model_info, filename):
        """Save regression model to JSON."""
        model_data = {
            'model_type': 'linear_regression',
            'features': list(model_info['features']),
            'coefficients': model_info['model'].coef_.tolist(),
            'intercept': float(model_info['model'].intercept_),
            'r2_score': model_info['r2'],
            'version': '1.0',
            'description': 'APBS electrostatic potential calibration model'
        }
        
        # Add preprocessor info if present
        if 'preprocessor' in model_info:
            model_data['preprocessor'] = 'polynomial_degree_2'
            model_data['poly_powers'] = model_info['preprocessor'].powers_.tolist()
        
        with open(filename, 'w') as f:
            json.dump(model_data, f, indent=2)
    
    def plot_calibration_results(self, df, model_info):
        """Create calibration visualization plots."""
        fig, axes = plt.subplots(2, 2, figsize=(12, 10))
        
        # ψ vs GC content
        axes[0,0].scatter(df['gc_frac'], df['psi_APBS'], alpha=0.7)
        axes[0,0].set_xlabel('GC Fraction')
        axes[0,0].set_ylabel('ψ_APBS (kT/e)')
        axes[0,0].set_title('Electrostatic Potential vs GC Content')
        
        # ψ vs CpG density  
        axes[0,1].scatter(df['cpg_density'], df['psi_APBS'], alpha=0.7)
        axes[0,1].set_xlabel('CpG Density')
        axes[0,1].set_ylabel('ψ_APBS (kT/e)')
        axes[0,1].set_title('Electrostatic Potential vs CpG Density')
        
        # Model fit
        X = df[['gc_frac', 'cpg_density', 'run_frac']].values
        y = df['psi_APBS'].values
        valid_mask = np.isfinite(y)
        
        if 'preprocessor' in model_info:
            y_pred = model_info['model'].predict(
                model_info['preprocessor'].transform(X[valid_mask])
            )
        else:
            y_pred = model_info['model'].predict(X[valid_mask])
        
        axes[1,0].scatter(y[valid_mask], y_pred, alpha=0.7)
        axes[1,0].plot([y.min(), y.max()], [y.min(), y.max()], 'r--')
        axes[1,0].set_xlabel('Observed ψ_APBS')
        axes[1,0].set_ylabel('Predicted ψ_APBS')
        axes[1,0].set_title(f'Model Fit (R² = {model_info["r2"]:.3f})')
        
        # Residuals
        residuals = y[valid_mask] - y_pred
        axes[1,1].scatter(y_pred, residuals, alpha=0.7)
        axes[1,1].axhline(y=0, color='r', linestyle='--')
        axes[1,1].set_xlabel('Predicted ψ_APBS')
        axes[1,1].set_ylabel('Residuals')
        axes[1,1].set_title('Residual Plot')
        
        plt.tight_layout()
        plt.savefig(self.work_dir / 'calibration_plots.png', dpi=300, bbox_inches='tight')
        plt.close()
        
        print(f"Calibration plots saved to {self.work_dir / 'calibration_plots.png'}")

if __name__ == "__main__":
    # Run calibration
    calibrator = APBSCalibration()
    results_df, model = calibrator.run_full_calibration()
    
    if model is not None:
        print("\n=== Calibration Summary ===")
        print(f"R² score: {model['r2']:.3f}")
        print(f"Model features: {model['features']}")
        print("Calibration complete!")
    else:
        print("Calibration failed - check error messages above") 